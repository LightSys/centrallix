// Copyright (C) 1998-2004 LightSys Technology Services, Inc.
//
// You may use these files and this library under the terms of the
// GNU Lesser General Public License, Version 2.1, contained in the
// included file "COPYING" or http://www.gnu.org/licenses/lgpl.txt.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.

//------------------

// by Seth Bird:

// client-side interface module. This is actually separate from the
// concept of a widget "interface" (I believe).

// Sometimes, in javascript development, a coder wants to "bind" a
// specific object to always be used as the 'this' pointer for some
// given function. One model of how to do this is by means of
// Prototype's 'bind' function
// (http://prototypejs.org/api/function/bind). The model used in
// Centrallix is a little more complicated...

// Instead of storing actually-bounded functions, Centrallix uses a
// bunch of 'Client Interfaces' -- which is a hash of just normal
// functions that the coder "wants" to be bound to some object. This
// then requires a lot of overhead wrappers (stored in the Client
// Interface instance) which will ensure for the coder that these
// functions are being passed the intended object.

// also, some code implementation of asynchronous request
// overhead/management (for interfaces) seem to occur here. I don't
// think it would be needed if it's ever refactered to use AJAX.





// GLOBALS

// as far as I can tell, this is used for just overhead/management of async requests for interfaces
var IFC=    {	Layer: null,
		BaseDir: "",
		Categories: {},
		Definitions: {},
		Loading: {},
		Callbacks: {},
		Params: {},
		Handles: {}
	    };


function IfcDefinition(path, type)
    {
	this.Path = path;
	this.Type = type;
	this.MajorVersions = new Array();
	this.DEFINITION = true;
    }

// ifc_internal_LoadFinished - callback function, called when an interface def
// has been loaded from the server, and is ready for parsing
function ifc_internal_LoadFinished()
    {
    var tokens,	i, maj_v_num, min_v_num, def, def_ref, cat;

	// get the tokens array
	if (IFC.Layer.document) tokens = IFC.Layer.document.links;
	else tokens = IFC.Layer.links;

	def_ref = tokens[tokens.length-1].pathname;
	delete IFC.Loading[def_ref];
	// see if there was an error
	if (tokens.length == 0 || tokens[tokens.length-1].target != "OK")
	    {
	    pg_debug("IFC: Error loading interface from server: ");
	    if (tokens.length > 0) pg_debug(tokens[tokens.length-1].target);
		pg_debug("\n");
	    return;
	    }
	
	pg_debug("IFC: Loaded '"+def_ref+"'interface successfully\n");

	// now start parsing the structure
	i=0;
	def = new IfcDefinition(def_ref, tokens[tokens.length-1].name);
	while (i < tokens.length - 2)
	    {
	    // first tag should be a start tag w/ major and minor version numbers
	    if (tokens[i].target != "start")
		{
		pg_debug("IFC: Expected a major version start tag. Text was '"+tokens[i].target+"'\n");
		return;
		}
	    maj_v_num = parseInt(tokens[i].host.substr(1, tokens[i].host.length-1));
	    if (isNaN(maj_v_num))
		{
		pg_debug("IFC: Invalid major version number '"+tokens[i].host+"'\n");
		return;
		}
	    pg_debug("IFC: Processing major version "+maj_v_num+"\n");
	    i++;    // next tag

	    def.MajorVersions[maj_v_num] = new Array();

	    // process each minor version
	    while (tokens[i].target != "end")
		{
		prop = 0;
		if (tokens[i].target != "start")
		    {
		    pg_debug("IFC: Expected a minor version start tag. Text was '"+tokens[i].target+"'\n");
		    return;
		    }
		min_v_num = parseInt(tokens[i].host.substr(1, tokens[i].host.length-1));
		if (isNaN(min_v_num))
		    {
		    pg_debug("IFC: Invalid minor version number '"+tokens[i].host+"'\n");
		    return;
		    }
		pg_debug("IFC:   Processing minor version "+min_v_num+"\n");
		i++;	// next tag

		def.MajorVersions[maj_v_num][min_v_num] = new Object();
		def.MajorVersions[maj_v_num][min_v_num].HANDLE = true;

		// process each category
		while (tokens[i].target != "end")
		    {
		    pg_debug("IFC:     Processing category '"+tokens[i].host+"'\n");
		    if (tokens[i].target != "end") //SETH: ?? why this test? it really is already known/implied
			{
			cat = tokens[i].host;
			def.MajorVersions[maj_v_num][min_v_num][cat] = new Object();
			pg_debug(maj_v_num+"."+min_v_num+" "+cat+"\n");
			}
		    i++;
		    // process each property
		    while (tokens[i].target != "end")
			{
			pg_debug("IFC:       Processing property '"+tokens[i].host+"'\n");

			// create the properties object via the inline object instantiation generated by the server
			eval("def.MajorVersions[maj_v_num][min_v_num][cat][tokens[i].host] = "+tokens[i].text);
			i++;
			}
		    i++;
		    }
		i++;	// next tag
		}
	    i++;    // next tag
	    }
	pg_debug("IFC: Done parsing interface definition\n");
	IFC.Definitions[def_ref] = def;
	IFC.Callbacks[def_ref] && IFC.Callbacks[def_ref](IFC.Params[def_ref]); //SETH: $$$callback$$$: should always call callback; but sometimes there'll be a blank callback //SETH: shouldn't these callbacks be handles by custom handlers?
	delete IFC.Callbacks[def_ref];
	delete IFC.Params[def_ref];
    }


// ifcLoadDef - instructs the interface module to load an interface
// definition from the server. handles will not be retrievable from
// that definition until it has completed loading
function ifcLoadDef(def_str, func)
    {
	// make sure the path is an absolute reference
	if (def_str[0] != '/') def_str = IFC.BaseDir+"/"+def_str;

	// check to see if it's already been loaded
	if (typeof IFC.Definitions[def_str] != "undefined")
	    {
	    pg_debug("IFC: '"+def_str+"' has already been loaded\n");
	    return;
	    }
	
	// check to see if it's currently loading
	if (typeof IFC.Loading[def_str] != "undefined")
	    {
	    pg_debug("IFC: already loading '"+def_str+"'\n");
	    return;
	    }

	// specify this def as 'loading'
	IFC.Loading[def_str] = true;
	IFC.Callbacks[def_str] = func; //SETH: //TODO: .... = func || function(){} (see $$$callback$$$)

	// now we can start the load
	pg_debug("ifcLoadDef("+def_str+") - starting load\n");
	pg_serialized_load(IFC.Layer, def_str, ifc_internal_LoadFinished);
    }


// ifcGetHandle - retrieves a handle to an interface 
function ifcGetHandle(ifc_str)
    {
    var maj_v_num, min_v_num, path, ver, tmp, def, handle, i, j, cat, member;

	// unpack the major and minor version numbers
	tmp = ifc_str.split('?');
	if (tmp.length != 2)
	    {
	    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' is not a valid interface reference\n");
	    return null;
	    }
	path = tmp[0];
	ver = tmp[1].split(/[.=]/);
	if (ver.length != 3 || ver[0] != 'cx__version')
	    {
	    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' has misformatted version\n");
	    return null;
	    }
	maj_v_num = parseInt(ver[1]);
	min_v_num = parseInt(ver[2]);
	if (isNaN(maj_v_num) || isNaN(min_v_num))
	    if (ver.length != 3 || ver[0] != 'cx__version')
		{
		    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' has misformatted version number\n");
		    return null;
		}

	// make sure the path is absolute
	if (path[0] != '/') path = IFC.BaseDir+"/"+path;

	// look up the interface definition
	if ( (def = IFC.Definitions[path]) == null)
	    {
	    pg_debug("IFC: couldn't find interface definition '"+path+"'\n");
	    return null;
	    }

	// build the handle
	return def[maj_v_num][min_v_num];
    }

function ifcInitialize(ifc_base_dir)
    {
	// assign the layer, browser-independently
	// FIXME FIXME This probably isn't such a hot way to do things FIXME FIXME
	if (document.getElementById) IFC.Layer = document.getElementById('ifc_layer');
	else if (document.all) IFC.Layer = document.all['ifc_layer'];
	else if (document.layers) IFC.Layer = document.layers['ifc_layer'];

	IFC.BaseDir = ifc_base_dir;
    }


// ------------------------------------------------------------------------
// The following are routines for internal interfaces within the javascript
// client widgets


// The ClientInterface constructor will construct a 'Client
// Interface'. A client interface is simply a hash of
// "desired-to-be-bound" functions along with needed management
// functions. (see documentation at top of this file)
function ClientInterface(thisObj, interfaceInitializer)
    {
    interfaceInitializer.call(this);
    this.obj = thisObj;
    }

// this initializer is what sets up a javascript object to mimic
// multiple inheritance (see code description at top).
function ifc_init_widget(w)
    {
    w.__ifc = {};
    w.ifcProbe = ifc_probe;
    w.ifcProbeAdd = ifc_probe_add;
    return;
    }

// this function creates a 'ClientInterface' which conceptually binds
// {the widget pointed to by 'this'} to certain methods. (see
// documentation at top of file)
function ifc_probe_add(i)
    {
    if (typeof i.name != 'undefined')
	var nm = i.name;
    else
	var nm = i.toString().substr(9,100).split('(')[0];
    if (!this.ifcProbe(i))
	this.__ifc[nm] = new ClientInterface(this,i);
    return this.__ifc[nm];
    }

//checks to see if the 'this' widget is associated with an interface 'i'.
function ifc_probe(i)
    {
    if (typeof i.name != 'undefined')
	var nm = i.name; //most browsers automatically create the .name property of functions
    else //assume is IE. do a hack
	var nm = i.toString().substr(9,100).split('(')[0];

    if (this.__ifc[nm]) 
	return this.__ifc[nm]; //__ifc[nm] will be an instance of ClientInterface;
    else
	return null;
    }


// ----------------------------------------------------------------------
// Interface Initializers
// ----------------------------------------------------------------------
// The following are classes that a 'Client Interface' can derive
// from.


// the Action interface Initializer - allows outside objects to invoke
// 'actions' on a given widget.
function ifAction()
    {
    function ifaction_invoke(a,ap) //ap stands for [a]ction [p]arameters (a hash of parameters)
	{
	if (this.Actions[a]) 
	    return this.Actions[a].call(this.obj, ap);
	else if (pg_diag)
	    alert("Invoke action: " + this.obj.id + " does not implement action " + a);
	return null;
	}
    function ifaction_schedinvoke(a,ap,d)
	{
	if (this.Actions[a])
	    {
	    pg_addsched_fn(this, "Invoke", [a, ap], d);
	    }
	else
	    {
	    alert("SchedInvoke action: " + this.obj.id + " does not implement action " + a);
	    }
	}
    function ifaction_add(a, f)
	{
	this.Actions[a] = f;
	}
    function ifaction_exists(a)
	{
	return (this.Actions[a])?true:false;
	}
    this.Actions = [];
    this.Add = ifaction_add;
    this.Exists = ifaction_exists;
    this.Invoke = ifaction_invoke;
    this.SchedInvoke = ifaction_schedinvoke;
    }


// Event interface - allows outside objects to hook into events which
// occur on the widget.
//
// the Event class (it seems to me) is really just a set of event
// management functions that differ from the already in-built event
// management functions in the browser. (to allow custom events).
//
function ifEvent()
    {
    function ifevent_add(e)
	{
	this.Events[e] = [];
	}
    function ifevent_clear(e)
	{
	if (this.Events[e])
	    this.Events[e] = new Array();
	else if (pg_diag)
	    alert("Clear events: " + this.obj.id + " does not implement event " + e);
	}
    function ifevent_hook(e,f,t)
	{
	if (this.Events[e])
	    {
	    eo = {fn:f, name:e};
	    if (t)
		eo.eo = t;
	    else
		eo.eo = this.obj;
	    this.Events[e].push(eo);
	    }
	else if (pg_diag)
	    alert("Hook event: " + this.obj.id + " does not implement event " + e);
	}
    function ifevent_activate(e,ep) //e = event (a string), ep = event parameters
	{
	var rval = null;
	ep._Origin = wgtrGetName(this.obj);
	if (this.Events[e])
	    {
	    var eventList = this.Events[e];
	    var len = eventList.length;
	    for(var ev=0; ev<len;ev++)
		{
		rval = eventList[ev].fn.call(eventList[ev].eo, ep);
		}
	    }
	else if (pg_diag)
	    {
	    alert("Activate event: " + this.obj.id + " does not implement event " + e);
	    }
	return rval;
	}
    function ifevent_connect_exec(ep)
	{
	var t = wgtrGetNode(this.to, this.target)
	// var t = eval(this.target);
	if (!t || !t.ifcProbe) 
	    {
	    if (pg_diag)
		alert("Event " + this.name + " -> Action " + this.action + ": target '" + this.target + "' not a widget");
	    return null;
	    }
	var ai = t.ifcProbe(ifAction);
	if (!ai) return null;
	var ap = new Object;
	ap._Origin = ep._Origin;
	for(var pn in this.paramlist)
	    {
	    var p = this.paramlist[pn];
	    if (p.type == 'int' || p.type == 'str' || p.type == 'dbl')
		ap[pn] = p.value;
	    else if (p.type == 'sym')
		{
		ap[pn] = wgtrGetNode(this.to, p.value);
		}
	    else if (p.type == 'exp')
		{
		var _context = this.to;
		//if (pn == 'Source') htr_alert(this, 1);
		if (cx__capabilities.JS15)
		    {
		    ep._context = this.to;
		    ap[pn] = eval(p.value, ep);
		    }
		else
		    {
		    if (typeof ep.eval != 'function')
			ep.eval = eval;
		    ap[pn] = ep.eval(p.value);
		    }
		}
	    }
	return ai.Invoke(this.action, ap);
	}
    function ifevent_connect(e,t,a,pl)
	{
	if (this.late_binding && !this.Events[e])
	    {
	    this.Add(e);
	    }
	if (this.Events[e])
	    {
	    eo = {to:this.obj, fn:ifevent_connect_exec, target:t, action:a, paramlist:pl, name:e};
	    eo.eo = eo;
	    this.Events[e].push(eo);
	    }
	else if (pg_diag)
	    alert("Connect event: " + this.obj.id + " does not implement event " + e);
	}
    function ifevent_exists(e)
	{
	return (this.Events[e])?true:false;
	}
    function ifevent_enable_late()
	{
	this.late_binding = true;
	}
    this.late_binding = false;
    this.EnableLateConnectBinding = ifevent_enable_late;
    this.Events = [];
    this.Add = ifevent_add;
    this.Hook = ifevent_hook;
    this.Activate = ifevent_activate;
    this.Connect = ifevent_connect;
    this.Exists = ifevent_exists;
    this.Clear = ifevent_clear;
    }


// Value interface. A Value instance is really just a container of
// key/value pairs.
function ifValue()
    {
    function ifvalue_checkexist(n)
	{
	if (!this._Attributes[n])
	    this._Attributes[n] = {name:n, exists:false, obj:this.obj, instance:this, watchlist:[], get:null, set:null};
	return this._Attributes[n];
	}
    function ifvalue_getvalue(n)
	{
	var a = this._CheckExist(n);
	if (a.exists)
	    {
	    if (a.propname)
		return this.obj[a.propname];
	    else
		return a.get.call(this.obj, n);
	    }
	else if (pg_diag && !this._NullNotExist)
	    alert("Get value: " + this.obj.id + " does not implement value " + n);
	else if (this._NullNotExist)
	    return this._NullNotExist.get.call(this.obj, n);
	return null;
	}
    function ifvalue_setvalue(n, v)
	{
	var a = this._CheckExist(n);
	if (a.exists)
	    {
	    if (a.propname)
		return this.obj[a.propname] = v;
	    else if (a.set)
		return a.set.call(this.obj, n, v);
	    else
		return null;
	    }
	else if (pg_diag && !this._NullNotExist)
	    alert("Set value: " + this.obj.id + " does not implement value " + n);
	else if (this._NullNotExist && this._NullNotExist.set)
	    return this._NullNotExist.set.call(this.obj, n, v);
	return null;
	}
    function ifvalue_exists(n, honest)
	{
	var a = this._CheckExist(n);
	if (honest) return a.exists;
	if (this._NullNotExist && a.exists == false) return true;
	return a.exists;
	}
    function ifvalue_change_cb(a, ov, nv)
	{
	return this.ifcProbe(ifValue).Changing(a, nv, false, ov);
	}
    function ifvalue_add(n, get_cb, set_cb)	
	{
	var a = this._CheckExist(n);
	if (typeof get_cb == 'string')
	    {
	    a.propname = get_cb;
	    a.obj.__ifvalue_changed = ifvalue_change_cb;
	    htr_watch(a.obj, a.propname, '__ifvalue_changed');
	    }
	else
	    {
	    a.get = get_cb;
	    a.set = set_cb;
	    }
	a.exists = true;
	}
    function ifvalue_remove(n)
	{
	var a = this._CheckExist(n);
	if (a.exists && a.propname)
	    {
	    htr_unwatch(a.obj, a.propname, '__ifvalue_changed');
	    }
	a.exists = false;
	}
    function ifvalue_setnonexistentcallback(get_cb, set_cb)
	{
	this._NullNotExist = {get:get_cb, set:set_cb};
	}
    function ifvalue_watch(attr, func)
	{
	var a = this._CheckExist(attr);
	for(var i in a.watchlist)
	    if (a.watchlist[i] == func) return;
	a.watchlist.push(func);
	}
    function ifvalue_unwatch(attr, func)
	{
	var a = this._CheckExist(attr);
	for(var i in a.watchlist)
	    if (a.watchlist[i] == func)
		{
		a.splice(i, 1);
		return;
		}
	}
    function ifvalue_changing(attr, value, force, oldval, oldval_is_set)
	{
	var a = this._CheckExist(attr);
	var changev = null;
	if (oldval == null && !oldval_is_set)
	    {
	    var gf = a.exists?a.get:(this._NullNotExist?this._NullNotExist.get:null);
	    if (!gf)
		{
		if (a.propname)
		    oldval = this.obj[a.propname];
		else
		    return value;
		}
	    else
		oldval = gf.call(this.obj, attr);
	    }
	for(var i in a.watchlist)
	    {
	    changev = a.watchlist[i].call(this.obj, attr, oldval, value);
	    if (!force) value = changev;
	    }
	return value;
	}

    // Internal declarations
    this._CheckExist = ifvalue_checkexist;
    this._NullNotExist = null; // if defined, this is the handler that runs whenever a value is null or does not exist (instead of an error occurring)
    this._Attributes = {};

    // Observer functions
    this.getValue = ifvalue_getvalue;
    this.setValue = ifvalue_setvalue;
    this.Exists = ifvalue_exists;
    this.Watch = ifvalue_watch;
    this.Unwatch = ifvalue_unwatch;

    // Host functions
    this.Add = ifvalue_add;
    this.Remove = ifvalue_remove;
    this.SetNonexistentCallback = ifvalue_setnonexistentcallback;
    this.Changing = ifvalue_changing;
    }


// Form Element interface
function ifFormElement(field)
    {
    function iffe_getvalue()
	{
	return this.Value;
	}
    this.Field = field;
    this.Value = null;
    this.PrivSetValue = iffe_priv_setvalue;
    this.PrivSetValueChangeCallback = iffe_priv_setvaluechangecallback;
    this.SetValue = iffe_setvalue;
    this.SetValueChangeCallback = iffe_setvaluechangecallback;
    this.GetValue = iffe_getvalue;
    this.SetFocus = iffe_setfocus;
    this.SetEnabled = iffe_setenabled;
    this.SetReadOnly = iffe_setr
    this.KeyInput = iffe_keyinput;
    }

