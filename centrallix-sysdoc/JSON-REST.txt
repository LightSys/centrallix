Document:   RESTful JSON API to access Centrallix OSML data
Author:	    Greg Beeley (GRB)
Date:	    05-Jun-2014
-------------------------------------------------------------------------------


OVERVIEW...

    The use of JSON for data exchange over HTTP connections (GET, POST, PUT)
    has become the defacto standard for web services APIs in recent years.
    This document describes the implementation of a RESTful JSON-based API in
    Centrallix, for access to data stored in the ObjectSystem.


ABOUT REST...

    REST stands for REpresentational State Transfer.  It is not a protocol
    specification, but is an approach to implementing protocols over HTTP and
    HTTPS.  There are a few key concepts to understand:

    A.	Collections.  A Collection contains a set of REST elements.  This maps
	to a list of Subobjects of an Object within the OSML.

    B.	Elements.  An Element is an object or document.  This maps to an
	Object within the OSML.

    C.	Stateless Operation.  REST is a stateless architectural element, which
	means that the concept of "opening" and "closing" resources or queries
	is nonexistent in REST.

    D.	Methods Used.  REST makes use of GET, POST, PUT, PATCH, and DELETE.  
	These methods map into the standard object access categories below:

	    1.	GET = Read information from an element or a collection

	    2.	PUT = Replace (i.e., update) or create information if the 
		exact URL of the element is known in advance (i.e., the name
		or ID of the element is known rather than depending on the
		server and database backend to create the name).  When
		updating an element, the entire element is overwritten.

	    3.	POST = Create information, by POSTing to a collection URL to
		create a new entity.  POST is used to create when the ID or
		name of the new entity is not known by the client in advance
		(where the server needs to automatically generate the name,
		such as in autonumber or autoincrement situations).

	    4.	DELETE = Delete information, by DELETING the element URL.

	    5.	PATCH = Update part of an element, by providing only the
		information about the new element that is different from the
		old element.

    REST does not require the use of a particular data format for requests or
    responses.  Data can be in JSON, XML, or any other format of the API
    designer's choosing.


ABOUT JSON...

    JSON, or JavaScript Object Notation, is the use of what is essentially a
    subset of JavaScript to represent an object's attributes and data (there
    are some subtle differences from normal JavaScript however).  It requires
    the use of quoted attribute names, and allows certain unescaped characters
    that would not parse properly in normal JavaScript.

    JSON defines six fundamental data types:  Objects, Arrays, Strings,
    Numbers, Booleans, and the special untyped null value.

    Data from the Centrallix OSML will be represented in JSON in a format
    described below in this document.

    An additional recommended standard, called JSON-LD (for "JSON Linked Data")
    is used to specify the links required by the REST architecture.  JSON-LD
    properties can be identified by starting with an "@" character.


OSML JSON DATA FORMAT...

    Data will be represented in one of two possible formats, a basic format,
    and an full format containing metadata.

    A.	Basic Format:

	In the Basic Format, only attribute names and values are supplied.
	This is appropriate for simple API integrations, and represents a
	traditional JSON data format.  For an Object, there will be one top-
	level JSON object container, with a list of attributes inside of it:

	    { "first_name":"John", "last_name":"Smith" }

	Centrallix has five fundamental data types: Integer, Double, String,
	Money, and Datetime.  These will be mapped to JSON data as follows:

	Integer:

	    "age":32

	Double:
	
	    "percent":95.5

	String:

	    "first_name":"John"

	Money:

	    { "wholepart":100, "fractionpart":0 }

	Datetime:

	    { "year":2013, "month":1, "day":1, "hour":12, "minute":10,
		"second":10 }

	And, finally, for null values:

	    "org_name":null

    B.	Full Format

	The Full Format will be used to transfer metadata about each
	attribute in addition to the attribute's name and value:

	    { "a":"age", "e":null, "v":32, "t":"integer", "h":"d=0" }

	In the above representation, the property names are abbreviated for
	space savings, and mean the following:

	    a = name of attribute
	    e = error status, null (or not present) if no error.  If set, it
		will either be the string "error" or a string containing an
		error message.
	    v = attribute's value (same representation as in the Basic Format)
	    t = data type (integer, double, string, money, datetime)
	    h = presentation hints, as encoded by hntEncodeHints() and as
		decoded by cx_parse_hints in JavaScript.  If no hints are
		available, the h property may be omitted entirely.

	The 'a' property above will be omitted if the name has already been
	specified outside of the full format attribute, for instance if
	a list of attributes is contained in a JSON Object.

    C.	Encoding entire objects in JSON

	The encoding of entire objects in JSON will be done by placing the
	attributes inside a JSON Object.  Below are examples of this being
	done with both the basic and full attribute formats:

	Basic:

	    {
		"@id":"/people/001?cx__mode=rest&cx__res_format=attrs",
		"first_name":"John",
		"last_name":"Smith"
	    }

	Full:

	    {
		"@id":"/people/001?cx__mode=rest&cx__res_format=attrs&cx__res_attrs=full",
		"first_name": { "v":"John", "t":"string", "h":"l=64" }
		"last_name": { "v":"Smith", "t":"string", "h":"l=64" }
	    }

    D.	Encoding a whole collection in JSON

	A collection will be encoded as a list of objects, but will default
	to not including any attributes at all.  Here is an example collection
	listing the modules installed in Kardia:

	{
	    "@id":"/apps/kardia/modules?cx__mode=rest&cx__res_type=collection",
	    "base": { "@id":"/apps/kardia/modules/base?cx__mode=rest" },
	    "crm": { "@id":"/apps/kardia/modules/crm?cx__mode=rest" },
	    "disb": { "@id":"/apps/kardia/modules/disb?cx__mode=rest" },
	    "gl": { "@id":"/apps/kardia/modules/gl?cx__mode=rest" },
	    "payroll": { "@id":"/apps/kardia/modules/payroll?cx__mode=rest" },
	    "rcpt": { "@id":"/apps/kardia/modules/rcpt?cx__mode=rest" }
	}

	URI parameters will be able to be supplied (see below) to control
	whether attributes are included in collection lists.

	If additional attributes are included in the collection listing, then
	they will be included at the same level as the @id JSON-LD property,
	such as in the following snippet:

	    "base":
		{
		"@id":"/apps/kardia/modules/base?cx__mode=rest",
		"someattr": "attrvalue"
		}


REST INTERFACE URI PARAMETERS...

    A.	Identifying the use of the REST interface

	The Centrallix HTTP/HTTPS interface currently has multiple existing
	API's that it supports.  In order to additionally support REST, the
	following URI parameter is required:

	    cx__mode=rest

    B.	Collections vs Elements

	In REST, either a URI is a collection URI or an element URI.  However,
	in the OSML, an object can have both attributes and subobjects.  Thus,
	the OSML pathname alone is not sufficient to determine whether
	something is a collection or an element.  In order to differentiate
	the type of resource, the cx__res_type URI parameter is required on
	all requests for a collection, since it defaults to Element mode.  It
	can be specified as follows:

	    cx__res_type=collection
	    cx__res_type=element	(default)

	("res" in the URI parameter above stands for "Resource", not for
	"REST".)

    C.	Content vs. Attributes

	Since an OSML object can have both attributes and content, and it is
	normal in REST to return the content in an element request, the
	following URI parameter can be used to force the server to respond
	one way or the other:

	    cx__res_format=attrs	(default for Collection)
	    cx__res_format=auto	
	    cx__res_format=content	(default for Element)
	    cx__res_format=both

	The 'both' option allows for any content to be encoded into the
	'cx__objcontent' property, thus providing a complete list of attributes
	as well as the content of the object.  Note that cx__objcontent is
	included in the JSON data as a simple (basic) property; it does not use
	the 'full' attribute format.

	The 'auto' option causes the system to return content if the object
	can have content, or to return an attributes document if the object
	cannot have content.  If the object can have content but does not, an
	empty response will be received (zero length).
	
	If retrieving a collection, then 'content' is disallowed and 'auto'
	works like 'attrs'.  The 'both' option can be used when retrieving a
	collection, however.

    D.	Selecting Basic vs Full attribute format

	To select the Basic or Full attribute format, include the
	following URI parameter.  This URI parameter can also be used to
	control whether attributes are shown in a Collection document.

	    cx__res_attrs=basic		(default for Element)
	    cx__res_attrs=full	
	    cx__res_attrs=none		(omit attrs: default for Collection)

	In a Collection document, the default is "none", which means to only
	include the names of the elements in the collection, but not any added
	information about them.  If the entire set of attributes is desired,
	then cx__attr_format can be used on a collection request to include
	them.

	If attributes are not being returned, then cx__res_attrs is ignored.


AUTHENTICATION...

    Although future authentication mechanisms may be supported later, the
    authentication mechanism currently used is HTTP Basic Auth.  This
    involves setting a WWW-Authenticate header with the username and password
    appended separated by a colon and then encoded with Base 64 encoding.
    Most HTTP clients should allow setting the username and password for HTTP
    Basic auth without having to manually construct the header, but if the
    header must be manually constructed, see the HTTP RFC for details.


RESPONSE MIME TYPES...

    If a response contains content (for an element), then the content type of
    the response will be the content type of the object's content, such as a
    PNG image or an HTML file.

    If a response contains attributes or a list of objects (collection), then
    the response content type will be "application/json".


EXAMPLE REQUESTS...

    A.	Retrieve a list of modules installed in Kardia

	Method: GET
	URI: http://server/apps/kardia/modules?cx__mode=rest&cx__res_type=collection

    B.	Get the module information data about one module:

	Method: GET
	URI: http://server/apps/kardia/modules/crm/kardia_modinfo.struct?cx__mode=rest&cx__res_format=attrs


